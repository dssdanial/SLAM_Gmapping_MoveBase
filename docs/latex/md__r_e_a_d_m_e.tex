A software architecture for the control of the robot in the environment. The software relys on the move\+\_\+base and gmapping packages for localizing the robot and plan the motion.

In this project, the software architecture should be able to get the user request, and let the robot execute one of the following behaviors (depending on the user’s input)\+: \begin{DoxyVerb}  1-  autonomously reach a x,y coordinate inserted by the user
  2-  let the user drive the robot with the keyboard
  3-  let the user drive the robot assisting them to avoid collisions
\end{DoxyVerb}



\begin{DoxyItemize}
\item The Robot can be obsereved in both Rviz and Gazebo environments as follows. 
\end{DoxyItemize}

 



 

This represents the point of view from Rviz. Rviz is a 3D visualization tool for R\+OS applications. It offers a view of the robot model, acquires sensor information from the robot sensors, and reproduces the acquired data. It can display data from video cameras, lasers, 3D and 2D devices, including images and point clouds. To obtain this result the robot must have explored all the surroundings since with the gmapping algorithm we do not have a totale knowledge of the environment, whereas with a pre-\/existing map we do.\hypertarget{md__r_e_a_d_m_e_autotoc_md0}{}\doxysection{\#\# How to Install and run}\label{md__r_e_a_d_m_e_autotoc_md0}
At first, some packages are required to be installed, if they aren\textquotesingle{}t already installed,it is possible to setup them by the following commands.


\begin{DoxyItemize}
\item Install xterm\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo apt install xterm}
\end{DoxyCode}

\item Using the S\+L\+A\+M-\/\+Gmapping package\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ git clone https://github.com/CarmineD8/slam\_gmapping.git}
\end{DoxyCode}

\item using the Navigation package\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo apt-\/get install ros-\/<your\_ros\_distro>-\/navigation}
\end{DoxyCode}

\item Install teleop-\/twist-\/keyboard package\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo apt-\/get install ros-\/<your\_ros\_distro>-\/teleop-\/twist-\/keyboard}
\end{DoxyCode}

\end{DoxyItemize}

After installing the required packages, it is time to run the simulation. Concequently, a launch file is porvided here as follows. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ roslaunch RTassignment3 main.launch}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Introduction}\label{md__r_e_a_d_m_e_autotoc_md1}

\begin{DoxyItemize}
\item Regarding the first goal, the {\ttfamily move\+\_\+base} pakage requires goal to be sent to the topic {\ttfamily move\+\_\+base/goal}, by sending a message of type {\ttfamily move\+\_\+base\+\_\+msgs/\+Move\+Base\+Action\+Goal}.
\item Regarding the goals 2) and 3), it should rely on the {\ttfamily teleop\+\_\+twist\+\_\+keyboard}, however, in case 3), the cmd\+\_\+vel may need to be corrected when the user is going to crash into obstacles. Carefully consider the architecture of the system.
\item Concerning the goal 3), the robot should not go forward if there is an obstacle in the front, also should not turn left/right if there are obstacles on the left/right.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{Interface Node}\label{md__r_e_a_d_m_e_autotoc_md2}
The purpose of this node is showing an interface in which the user can choose different modes, reset the simulation or quit the execution of the program. When an input is given, the node runs the correct command to launch the related node.

The interface is simply designed as a list of commands as follows\+:

 \hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{(\+I) Autonomous X\+Y-\/\+Position Node}\label{md__r_e_a_d_m_e_autotoc_md3}
Once a x-\/y position receieved by user, this node drives the robot to the desired position in the environment. First of all the node requires from the user the {\ttfamily x} and {\ttfamily y} position of the goal, then a message of type {\ttfamily move\+\_\+base\+\_\+msgs/\+Move\+Base\+Action\+Goal} is generated and published in the {\ttfamily /move\+\_\+base/goal} topic. Every goal is tracked by the node with its {\ttfamily id}, that is randomly generated inside the node itself.\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysection{Nodes struscture}\label{md__r_e_a_d_m_e_autotoc_md4}
 

After establishing the position, the user can at any time cancel the goal (pressing the {\ttfamily q} key) and quit the execurtion (pressing the {\ttfamily s} key). If one of the above keys is pressed, a message of type {\ttfamily actionlib\+\_\+msgs/\+Goal\+ID} is generated and then published in the {\ttfamily /move\+\_\+base/cancel} topic to cancel the goal.\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysection{video}\label{md__r_e_a_d_m_e_autotoc_md5}
The result of the $\ast$$\ast$\+\_\+first\+\_\+$\ast$$\ast$ task is shown as the following video\+:

\href{https://user-images.githubusercontent.com/32397445/182872817-f4ccb08b-4d68-4531-80b7-29de31634bc2.mp4}{\texttt{ https\+://user-\/images.\+githubusercontent.\+com/32397445/182872817-\/f4ccb08b-\/4d68-\/4531-\/80b7-\/29de31634bc2.\+mp4}}

In order to check wheather the robot has reached the goal or not, a {\ttfamily /move\+\_\+base/status} message handler is implemented. It checks the meassages published on the previously mentioned topic. In particular, when the robot stops, the status code becomes {\ttfamily 3} if the robot has reached the goal position, otherwise the status code becomes {\ttfamily 4} if the robot can not reach the given position.\hypertarget{md__r_e_a_d_m_e_autotoc_md6}{}\doxysection{(\+I\+I) Manual Drive-\/ $<$em$>$without$<$/em$>$ Obstacle Avoidance assistant}\label{md__r_e_a_d_m_e_autotoc_md6}
This node aims to give the user the possibility of moving the robot in the environment using the keyboard. In order to manage the robot\textquotesingle{}s movement in the environment four parameters are considred, two used for the velocity values (both linear and angular velocity) and two used for the directions. Each specific key modifies the above mentioned variables to drive the robot through the maze. Once the velocity and the direction has been modified new velocities are published in the {\ttfamily /cmd\+\_\+vel} topic.

An interface has been considered as a list of the commands to move the robot and increase/decrease velocities as follows\+:

 \hypertarget{md__r_e_a_d_m_e_autotoc_md7}{}\doxysection{Nodes struscture}\label{md__r_e_a_d_m_e_autotoc_md7}
 \hypertarget{md__r_e_a_d_m_e_autotoc_md8}{}\doxysection{Video}\label{md__r_e_a_d_m_e_autotoc_md8}
The result of the $\ast$$\ast$\+\_\+second\+\_\+$\ast$$\ast$ task is shown as the following video\+:

\href{https://user-images.githubusercontent.com/32397445/182872919-e427823f-907b-438d-9582-4881dcccf7d8.mp4}{\texttt{ https\+://user-\/images.\+githubusercontent.\+com/32397445/182872919-\/e427823f-\/907b-\/438d-\/9582-\/4881dcccf7d8.\+mp4}}\hypertarget{md__r_e_a_d_m_e_autotoc_md9}{}\doxysection{(\+I\+I\+I) Manual Drive-\/ $<$em$>$with$<$/em$>$ Obstacle Avoidance assistant}\label{md__r_e_a_d_m_e_autotoc_md9}
This is the last node developed, basically it aims to give the user the possibility to drive the robot in the environment using the keyboard, but in this case it is also necessary to provide obstacle avoidance autonomously. Since the goal is partially similar to what was done with the previous node, part of the code has been re-\/used for this node. To manage obstacle avoidance the robot laser scanner is used,and the node subscribes from the {\ttfamily /scan} topic. This topic provide a {\ttfamily ranges array} composed of 720 elements. The ranges array is filled with the distance of the obstacles in the {\ttfamily 180°} field of view of the robot. It is possible to divide the array in three parts (robot\textquotesingle{}s left right and front) and check the closest obstacle in each section, then if the robot will be close to an obstacle it will be properly rotated.\hypertarget{md__r_e_a_d_m_e_autotoc_md10}{}\doxysection{Nodes struscture}\label{md__r_e_a_d_m_e_autotoc_md10}
 \hypertarget{md__r_e_a_d_m_e_autotoc_md11}{}\doxysection{Video}\label{md__r_e_a_d_m_e_autotoc_md11}
The result of the $\ast$$\ast$\+\_\+third\+\_\+$\ast$$\ast$ task is shown as the following video\+:

\href{https://user-images.githubusercontent.com/32397445/182872987-ba6ce54d-a143-4cc3-a866-5fc8f35cb515.mp4}{\texttt{ https\+://user-\/images.\+githubusercontent.\+com/32397445/182872987-\/ba6ce54d-\/a143-\/4cc3-\/a866-\/5fc8f35cb515.\+mp4}}\hypertarget{md__r_e_a_d_m_e_autotoc_md12}{}\doxysection{Pseudo code}\label{md__r_e_a_d_m_e_autotoc_md12}
\hypertarget{md__r_e_a_d_m_e_autotoc_md13}{}\doxysection{control of the robot}\label{md__r_e_a_d_m_e_autotoc_md13}

\begin{DoxyCode}{0}
\DoxyCodeLine{listen for UI node's commands}
\DoxyCodeLine{}
\DoxyCodeLine{ if autonomous drive}
\DoxyCodeLine{   receive coordinates}
\DoxyCodeLine{   start driving action with coordinates}
\DoxyCodeLine{}
\DoxyCodeLine{ elseif manual drive}
\DoxyCodeLine{   redirect teleop\_twist\_keyboard node to cmd\_vel topic}
\DoxyCodeLine{}
\DoxyCodeLine{ elseif assisted drive}
\DoxyCodeLine{   run collision avoidance on teleop\_twist\_keyboard's commands}
\DoxyCodeLine{   send filtered commands to cmd\_vel}
\DoxyCodeLine{}
\DoxyCodeLine{ send info to Interface node}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md14}{}\doxysection{Coclusion and possible improvments}\label{md__r_e_a_d_m_e_autotoc_md14}
All proposed algorithms are executed correctly and the robot completed tasks as well. Results are satisfying, however, some improvements can be achieved.
\begin{DoxyItemize}
\item reaching a desired point seems taking some delays, so, this could be modified by tuning parameters.
\item A queue could be implemented where goals are reached sequentially.
\item When the map of the environment is completed, the robot is not able to understand the priori points whether it is reachable or not, which could be improved in further developments. 
\end{DoxyItemize}